/*
 * ReadsProcessor.cpp
 * Contains methods for formatting sequences to place into bloom filter
 *
 *  Created on: Aug 8, 2012
 *      Author: cjustin
 */
#include "ReadsProcessor.h"
#include <cassert>
#include <iostream>

//TODO: write unit tests for this class

/*
 * Needed for use of optimized char* returning prepSeq
 */
ReadsProcessor::ReadsProcessor(uint16_t windowSize) :
		kmerSize(windowSize), emptyResult(""), halfKmerSize(
				windowSize / 2 + windowSize % 2) {
	outputFwd.resize(windowSize);
	outputRev.resize(windowSize);
}

static const char b2C[256] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //0
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //1
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //2
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //3
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 'A', 0xFF, 'C', 0xFF, 0xFF, 0xFF, 'G', //4 A C G
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 'T', 0xFF, 0xFF, 0xFF, //5 T
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 'A', 0xFF, 'C', 0xFF, 0xFF, 0xFF, 'G', //6 a c g
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 'T', 0xFF, 0xFF, 0xFF, //7 t
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //8
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //9
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //A
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //B
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //C
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //D
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //E
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //F
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/* Prepares DNA sequence for insertion into bloom filter by:
 * - Turning all lower-case sequences to upper-case
 * - Also looks into reverse compliment version and returns consistently
 *   that which is smaller (convention used A<C<G<T, i.e. alphabetical)
 * - Converts input to empty string if any character other than ATCG is found
 *
 * requires a start position
 */
const string &ReadsProcessor::prepSeq(string const &sequence, size_t position) {

	uint16_t outputIndex = 0;
	size_t revIndex = position + kmerSize - 1;

	// determines which compliment to use
	// parse through string converting and checking for lower-case and non ATCG characters
	// half the length of seq because after this point will be palindromic and is not worth checking
	for (size_t index = position; outputIndex < halfKmerSize; ++index) {
		//modify the forward

		outputFwd[outputIndex] = b2C[sequence[index]];
		if (outputFwd[outputIndex] == 0xFF) {
			return emptyResult;
		}

		outputRev[outputIndex] = b2C[sequence[revIndex]];
		if (outputFwd[outputIndex] == 0xFF) {
			return emptyResult;
		}

		//compare and convert if not already established
		//forward is smaller
		if (outputFwd[outputIndex] < outputRev[outputIndex]) {
			//finish off sequence
			++index;
			++outputIndex;
			for (; outputIndex < kmerSize; ++index) {
				outputFwd[outputIndex] = b2C[sequence[index]];
				if (outputFwd[outputIndex] == 0xFF) {
					return emptyResult;
				}
				++outputIndex;
			}
			return outputFwd;
		}
		//reverse is smaller
		else if (outputFwd[outputIndex] > outputRev[outputIndex]) {
			//finish off sequence
			--revIndex;
			++outputIndex;
			for (; outputIndex < kmerSize; --revIndex) {
				outputRev[outputIndex] = b2C[sequence[revIndex]];
				if (outputFwd[outputIndex] == 0xFF) {
					return emptyResult;
				}
				++outputIndex;
			}
			return outputRev;
		}
		++outputIndex;
		--revIndex;
	}
	//palamdromic
	return outputFwd;
}

ReadsProcessor::~ReadsProcessor() {
}

